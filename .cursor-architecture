# Sungrow Inverter Control System - Architecture Documentation

## ğŸ—ï¸ System Overview
This is a **sandbox tooling project** for testing, monitoring, and controlling Sungrow solar inverters via Modbus TCP. The system is designed for experimentation with solar energy management algorithms and hardware integration testing.

## ğŸ“‹ Project Purpose
- **Primary**: Test and validate Sungrow inverter control via Modbus
- **Secondary**: Develop solar energy management and optimization algorithms  
- **Tertiary**: Create reusable tooling for solar system integration
- **Context**: Sandbox environment for hardware experimentation

## ğŸ›ï¸ Architecture Layers

### 1. Communication Layer
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Communication Layer         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ modbus_client.py                  â”‚
â”‚   - TCP connection management       â”‚
â”‚   - Register read/write operations  â”‚
â”‚   - Endianness handling            â”‚
â”‚   - Error handling & retries       â”‚
â”‚                                     â”‚
â”‚ â€¢ config.yaml                       â”‚
â”‚   - Register mappings (53 sensors)  â”‚
â”‚   - Control registers (13 writable) â”‚
â”‚   - Scaling factors & data types    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Control Layer  
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Control Layer             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ sungrow_controller.py             â”‚
â”‚   - High-level control interface    â”‚
â”‚   - Safety validation              â”‚
â”‚   - Energy balance calculations     â”‚
â”‚   - Control algorithm framework     â”‚
â”‚                                     â”‚
â”‚ â€¢ automation_example.py             â”‚
â”‚   - Smart optimization strategies   â”‚
â”‚   - Time-of-use logic              â”‚
â”‚   - Emergency protection           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Monitoring Layer
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Monitoring Layer           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ monitor.py                        â”‚
â”‚   - Real-time data visualization    â”‚
â”‚   - CLI interface with colors       â”‚
â”‚   - Trend analysis                  â”‚
â”‚                                     â”‚
â”‚ â€¢ simple_live_monitor.py            â”‚
â”‚   - Basic monitoring interface      â”‚
â”‚                                     â”‚
â”‚ â€¢ ui_renderer.py                    â”‚
â”‚   - Rich terminal UI components     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. Data & Analysis Layer
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Data & Analysis Layer        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ telemetry.py                      â”‚
â”‚   - Data logging and storage        â”‚
â”‚   - Historical analysis             â”‚
â”‚                                     â”‚
â”‚ â€¢ analysis.py                       â”‚
â”‚   - Performance analytics           â”‚
â”‚   - System optimization insights    â”‚
â”‚                                     â”‚
â”‚ â€¢ influxdb_pusher.py                â”‚
â”‚   - Time-series database integrationâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5. Testing & Debugging Layer
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Testing & Debug Layer         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ test_*.py files                   â”‚
â”‚   - Unit tests for hardware ops     â”‚
â”‚   - Integration testing             â”‚
â”‚                                     â”‚
â”‚ â€¢ debug_*.py files                  â”‚
â”‚   - Hardware diagnostic tools       â”‚
â”‚   - Register validation             â”‚
â”‚                                     â”‚
â”‚ â€¢ main.py                           â”‚
â”‚   - Complete system demonstration   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”— Data Flow Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    Modbus TCP    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Sungrow        â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  modbus_client  â”‚
â”‚  Inverter       â”‚   192.168.192.10 â”‚                 â”‚
â”‚  (Hardware)     â”‚      :502        â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  sungrow_       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   config.yaml   â”‚
â”‚  controller     â”‚  Register Maps   â”‚   53 sensors    â”‚
â”‚                 â”‚  & Scaling       â”‚   13 controls   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                     â”‚
         â–¼                                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Automation     â”‚                  â”‚   Monitoring    â”‚
â”‚  & Control      â”‚                  â”‚   & Display     â”‚
â”‚                 â”‚                  â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                     â”‚
         â–¼                                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Data Logging   â”‚                  â”‚   Analysis &    â”‚
â”‚  & Telemetry    â”‚                  â”‚   Optimization  â”‚
â”‚                 â”‚                  â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ—ï¸ Key Components Detail

### Core Modules

#### `modbus_client.py` (Communication Foundation)
- **Purpose**: Low-level Modbus TCP communication
- **Key Features**: 
  - Connection management with retries
  - Register read/write with proper endianness
  - Error handling and recovery
  - Support for both input/holding registers
- **Dependencies**: pymodbus, yaml
- **Hardware Interface**: Direct TCP connection to inverter

#### `sungrow_controller.py` (Control Brain)
- **Purpose**: High-level control and safety management
- **Key Features**:
  - Smart energy optimization algorithms
  - Safety validation for all control operations
  - Energy balance calculations
  - Battery and grid management
- **Dependencies**: modbus_client, config
- **Control Capabilities**: 13 writable registers

#### `config.yaml` (System Configuration)
- **Purpose**: Centralized register and system configuration
- **Key Features**:
  - 53 sensor register definitions
  - 13 control register mappings
  - Scaling factors and data types
  - Hardware-specific parameters
- **Format**: YAML with register addresses, types, scaling

### Monitoring & UI

#### `monitor.py` (Real-time Display)
- **Purpose**: Live system monitoring with rich terminal UI
- **Key Features**:
  - Real-time data updates (1-second intervals)
  - Color-coded status indicators
  - Rolling averages and trend analysis
  - Energy balance visualization
- **Dependencies**: rich, sungrow_controller

#### `telemetry.py` (Data Management)
- **Purpose**: Historical data logging and analysis
- **Key Features**:
  - Time-series data storage
  - Performance analytics  
  - System health monitoring
  - Integration with InfluxDB
- **Dependencies**: influxdb-client

### Testing & Development

#### Test Suite Structure
- `test_modbus.py` - Low-level register testing
- `test_solar_power.py` - Power calculation validation
- `main.py` - Complete system integration testing
- `debug_*.py` - Hardware diagnostic tools

## ğŸ›¡ï¸ Safety & Error Handling

### Hardware Safety Layers
1. **Connection Safety**: Automatic reconnection with exponential backoff
2. **Register Validation**: Range checking for all register operations
3. **Control Safety**: Validation of control parameters against limits
4. **Emergency Protection**: Emergency stop and safe state functionality
5. **Error Recovery**: Graceful degradation on communication failures

### Error Handling Strategy
```python
# Hardware operations always wrapped in safety checks
try:
    # Validate parameters
    if not self._validate_control_parameters(power):
        raise ValueError("Control parameters out of safe range")
    
    # Execute with timeout
    result = self.client.write_register(address, value)
    
    # Verify operation
    if not self._verify_control_result(result):
        raise ControlError("Control operation failed verification")
        
except Exception as e:
    logger.error(f"Control operation failed: {e}")
    self._enter_safe_state()
    raise
```

## ğŸ“Š Data Models

### System State
```python
@dataclass
class InverterState:
    solar_power: float          # W - Current solar generation
    battery_soc: float          # % - Battery state of charge  
    battery_power: float        # W - Battery charge/discharge
    grid_power: float           # W - Grid import/export
    grid_frequency: float       # Hz - Grid frequency
    running_state: int          # Status code
    timestamp: datetime         # Data timestamp
```

### Register Configuration
```python
@dataclass  
class RegisterConfig:
    address: int                # Modbus register address
    function_code: str          # 'input' or 'holding'
    data_type: str             # 'uint16', 'int32', etc.
    scale_factor: float        # Scaling multiplier
    endianness: str            # 'big' or 'little'
    writable: bool = False     # Control register flag
```

## ğŸš€ Extensibility Design

### Plugin Architecture
- **Inverter Models**: Support for multiple Sungrow models via config profiles
- **Control Algorithms**: Pluggable optimization strategies
- **Data Outputs**: Multiple backend support (InfluxDB, SQLite, CSV)
- **UI Interfaces**: Terminal, web, mobile-ready separation

### Configuration-Driven
- Register mappings externalized to YAML
- Algorithm parameters configurable
- Hardware addresses and timeouts configurable
- UI themes and display options configurable

## ğŸ¯ Development Patterns

### Key Design Principles
1. **Hardware First**: Always consider hardware limitations and safety
2. **Configuration Driven**: Minimize hardcoded values
3. **Testable**: Mock hardware for unit testing
4. **Observable**: Comprehensive logging and monitoring
5. **Recoverable**: Graceful error handling and recovery
6. **Extensible**: Plugin architecture for new features

### Common Patterns
- **Factory Pattern**: For different inverter models
- **Observer Pattern**: For real-time data updates  
- **Command Pattern**: For control operations with undo
- **Strategy Pattern**: For different optimization algorithms
- **Retry Pattern**: For hardware communication resilience

Remember: This is a **sandbox tooling project** - architecture prioritizes experimentation, clear interfaces, and safe hardware interaction over production scalability. 